
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>myapp: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/unregex/cmd/myapp/main.go (0.0%)</option>
				
				<option value="file1">github.com/unregex/internal/app/app.go (0.0%)</option>
				
				<option value="file2">github.com/unregex/internal/format/format.go (100.0%)</option>
				
				<option value="file3">github.com/unregex/internal/format/go.go (82.6%)</option>
				
				<option value="file4">github.com/unregex/internal/format/js.go (78.0%)</option>
				
				<option value="file5">github.com/unregex/internal/format/pcre.go (78.6%)</option>
				
				<option value="file6">github.com/unregex/internal/format/posix.go (0.7%)</option>
				
				<option value="file7">github.com/unregex/internal/format/python.go (0.4%)</option>
				
				<option value="file8">github.com/unregex/pkg/utils/utils.go (88.9%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "bufio"
        "flag"
        "fmt"
        "io"
        "os"
        "strings"

        "github.com/unregex/internal/app"
        "github.com/unregex/pkg/utils"
)

func main() <span class="cov0" title="0">{
        // Define command-line flags
        formatFlag := flag.String("format", "go", "Regex format/flavor (go, pcre, posix, js, python)")
        helpFlag := flag.Bool("help", false, "Show help message")
        versionFlag := flag.Bool("version", false, "Show version information")

        // Custom usage function
        flag.Usage = func() </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Unregex - %s\n\n", utils.Description())
                fmt.Fprintf(os.Stderr, "Usage:\n")
                fmt.Fprintf(os.Stderr, "  unregex [options] &lt;pattern&gt;\n")
                fmt.Fprintf(os.Stderr, "  echo '&lt;pattern&gt;' | unregex [options]\n\n")
                fmt.Fprintf(os.Stderr, "Options:\n")
                flag.PrintDefaults()
                fmt.Fprintf(os.Stderr, "\nExamples:\n")
                fmt.Fprintf(os.Stderr, "  unregex \"^hello(world|universe)[0-9]+$\"\n")
                fmt.Fprintf(os.Stderr, "  unregex -format pcre \"(?&lt;=look)behind\"\n")
                fmt.Fprintf(os.Stderr, "  echo \"a{2,4}b[a-z]*\\d+\" | unregex\n")
        }</span>
        
        // Parse command-line flags
        <span class="cov0" title="0">flag.Parse()
        
        // Show help message and exit
        if *helpFlag </span><span class="cov0" title="0">{
                flag.Usage()
                os.Exit(0)
        }</span>
        
        // Show version information and exit
        <span class="cov0" title="0">if *versionFlag </span><span class="cov0" title="0">{
                fmt.Println(utils.GetVersionInfo())
                os.Exit(0)
        }</span>
        
        <span class="cov0" title="0">fmt.Printf("Unregex - Regex Visualizer v%s\n\n", utils.Version)
        
        // Validate regex format
        format := strings.ToLower(*formatFlag)
        if !utils.IsValidFormat(format) </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: Unsupported regex format '%s'\n", format)
                fmt.Fprintf(os.Stderr, "Supported formats: go, pcre, posix, js, python\n")
                os.Exit(1)
        }</span>
        
        // Get regex pattern from arguments or stdin
        <span class="cov0" title="0">pattern, err := getRegexPattern()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: %v\n", err)
                fmt.Fprintln(os.Stderr, "Run 'unregex -help' for usage information")
                os.Exit(1)
        }</span>
        
        // Run the regex explanation with the selected format
        <span class="cov0" title="0">if err := app.Run([]string{pattern, format}); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: %v\n", err)
                os.Exit(1)
        }</span>
}

// getRegexPattern retrieves the regex pattern from command line arguments or stdin
func getRegexPattern() (string, error) <span class="cov0" title="0">{
        // Check if pattern is provided as a command line argument (after flags)
        if flag.NArg() &gt; 0 </span><span class="cov0" title="0">{
                return flag.Arg(0), nil
        }</span>
        
        // Check if data is being piped in through stdin
        <span class="cov0" title="0">stat, _ := os.Stdin.Stat()
        if (stat.Mode() &amp; os.ModeCharDevice) == 0 </span><span class="cov0" title="0">{
                // Data is being piped in
                reader := bufio.NewReader(os.Stdin)
                input, err := io.ReadAll(reader)
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to read from stdin: %v", err)
                }</span>
                
                // Trim whitespace and newlines
                <span class="cov0" title="0">pattern := strings.TrimSpace(string(input))
                if pattern == "" </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("empty pattern received from stdin")
                }</span>
                
                <span class="cov0" title="0">return pattern, nil</span>
        }
        
        // No pattern provided
        <span class="cov0" title="0">return "", fmt.Errorf("no regex pattern provided")</span>
} </pre>
		
		<pre class="file" id="file1" style="display: none">package app

import (
        "fmt"

        "github.com/unregex/internal/format"
)

// Run executes the main application logic
func Run(args []string) error <span class="cov0" title="0">{
        if len(args) == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("no regex pattern provided")
        }</span>

        <span class="cov0" title="0">pattern := args[0]
        
        // Get the format from args or default to "go"
        formatName := "go"
        if len(args) &gt; 1 </span><span class="cov0" title="0">{
                formatName = args[1]
        }</span>
        
        <span class="cov0" title="0">return ExplainRegex(pattern, formatName)</span>
}

// ExplainRegex parses and explains a regex pattern
func ExplainRegex(pattern, formatName string) error <span class="cov0" title="0">{
        // Get the appropriate regex format implementation
        regexFormat := format.GetFormat(formatName)
        
        fmt.Printf("Analyzing regex pattern: %s\n", pattern)
        fmt.Printf("Format: %s\n\n", regexFormat.Name())
        
        // Get features supported by this format
        printSupportedFeatures(regexFormat)
        
        // Tokenize and explain the pattern
        tokens := regexFormat.TokenizeRegex(pattern)
        
        for i, token := range tokens </span><span class="cov0" title="0">{
                explanation := regexFormat.ExplainToken(token)
                fmt.Printf("%d. %s: %s\n", i+1, token, explanation)
        }</span>
        
        <span class="cov0" title="0">fmt.Println("\nNOTE: This is a basic regex explainer. Some complex patterns might not be perfectly tokenized.")
        
        return nil</span>
}

// printSupportedFeatures prints a summary of features supported by the format
func printSupportedFeatures(regexFormat format.RegexFormat) <span class="cov0" title="0">{
        features := []struct {
                name        string
                code        string
                description string
        }{
                {name: "Lookahead", code: format.FeatureLookahead, description: "(?=pattern) or (?!pattern)"},
                {name: "Lookbehind", code: format.FeatureLookbehind, description: "(?&lt;=pattern) or (?&lt;!pattern)"},
                {name: "Named Groups", code: format.FeatureNamedGroup, description: "(?P&lt;name&gt;pattern)"},
                {name: "Atomic Groups", code: format.FeatureAtomicGroup, description: "(?&gt;pattern)"},
                {name: "Conditionals", code: format.FeatureConditional, description: "(?(cond)then|else)"},
                {name: "Possessive Quantifiers", code: format.FeaturePossessive, description: "a++, a*+, a?+"},
                {name: "Unicode Properties", code: format.FeatureUnicodeClass, description: "\\p{Property}"},
                {name: "Recursion", code: format.FeatureRecursion, description: "(?R) or (?0)"},
                {name: "Backreferences", code: format.FeatureBackreference, description: "\\1, \\2, etc."},
                {name: "Named Backreferences", code: format.FeatureNamedBackref, description: "\\k&lt;name&gt;"},
        }
        
        fmt.Println("Supported Features:")
        
        for _, feature := range features </span><span class="cov0" title="0">{
                supported := "✗"
                if regexFormat.HasFeature(feature.code) </span><span class="cov0" title="0">{
                        supported = "✓"
                }</span>
                <span class="cov0" title="0">fmt.Printf("  %s %s (%s)\n", supported, feature.name, feature.description)</span>
        }
        
        <span class="cov0" title="0">fmt.Println()</span>
} </pre>
		
		<pre class="file" id="file2" style="display: none">package format

// RegexFormat defines the interface for different regex format implementations
type RegexFormat interface {
        // Name returns the descriptive name of the format
        Name() string
        
        // TokenizeRegex breaks a regex pattern into meaningful tokens
        TokenizeRegex(pattern string) []string
        
        // ExplainToken provides a human-readable explanation for a regex token
        ExplainToken(token string) string
        
        // HasFeature checks if this format supports a specific regex feature
        HasFeature(feature string) bool
}

// Feature constants for different regex capabilities
const (
        FeatureLookahead      = "lookahead"
        FeatureLookbehind     = "lookbehind"
        FeatureNamedGroup     = "named_group"
        FeatureAtomicGroup    = "atomic_group"
        FeatureConditional    = "conditional"
        FeaturePossessive     = "possessive"
        FeatureUnicodeClass   = "unicode_class"
        FeatureRecursion      = "recursion"
        FeatureBackreference  = "backreference"
        FeatureNamedBackref   = "named_backref"
)

// GetFormat returns the appropriate RegexFormat implementation for the specified format
func GetFormat(formatName string) RegexFormat <span class="cov8" title="1">{
        switch formatName </span>{
        case "go":<span class="cov8" title="1">
                return NewGoFormat()</span>
        case "pcre":<span class="cov8" title="1">
                return NewPcreFormat()</span>
        case "posix":<span class="cov8" title="1">
                return NewPosixFormat()</span>
        case "js":<span class="cov8" title="1">
                return NewJsFormat()</span>
        case "python":<span class="cov8" title="1">
                return NewPythonFormat()</span>
        default:<span class="cov8" title="1">
                // Default to Go format
                return NewGoFormat()</span>
        }
}

// findClosingBracket finds the closing bracket for a character class
func FindClosingBracket(pattern string, start int) int <span class="cov8" title="1">{
        for i := start + 1; i &lt; len(pattern); i++ </span><span class="cov8" title="1">{
                if pattern[i] == ']' &amp;&amp; (i == start+1 || pattern[i-1] != '\\') </span><span class="cov8" title="1">{
                        return i
                }</span>
        }
        <span class="cov8" title="1">return -1</span>
}

// findClosingCurlyBrace finds the closing curly brace for a quantifier
func FindClosingCurlyBrace(pattern string, start int) int <span class="cov8" title="1">{
        for i := start + 1; i &lt; len(pattern); i++ </span><span class="cov8" title="1">{
                if pattern[i] == '}' &amp;&amp; pattern[i-1] != '\\' </span><span class="cov8" title="1">{
                        return i
                }</span>
        }
        <span class="cov8" title="1">return -1</span>
}

// findClosingParenthesis finds the closing parenthesis for a group
func FindClosingParenthesis(pattern string, start int) int <span class="cov8" title="1">{
        depth := 1
        for i := start + 1; i &lt; len(pattern); i++ </span><span class="cov8" title="1">{
                if pattern[i] == '\\' &amp;&amp; i+1 &lt; len(pattern) </span><span class="cov8" title="1">{
                        // Skip escaped characters
                        i++
                        continue</span>
                }
                <span class="cov8" title="1">if pattern[i] == '(' </span><span class="cov8" title="1">{
                        depth++
                }</span> else<span class="cov8" title="1"> if pattern[i] == ')' </span><span class="cov8" title="1">{
                        depth--
                        if depth == 0 </span><span class="cov8" title="1">{
                                return i
                        }</span>
                }
        }
        <span class="cov8" title="1">return -1</span>
} </pre>
		
		<pre class="file" id="file3" style="display: none">package format

import (
        "fmt"
        "strings"
)

// GoFormat implements the RegexFormat interface for Go regular expressions
type GoFormat struct{}

// NewGoFormat creates a new Go format implementation
func NewGoFormat() RegexFormat <span class="cov8" title="1">{
        return &amp;GoFormat{}
}</span>

// Name returns the descriptive name of the format
func (g *GoFormat) Name() string <span class="cov8" title="1">{
        return "Go Regexp"
}</span>

// HasFeature checks if this format supports a specific regex feature
func (g *GoFormat) HasFeature(feature string) bool <span class="cov8" title="1">{
        // Go regex has limited features compared to PCRE
        supportedFeatures := map[string]bool{
                FeatureLookahead:     true,  // Supports only positive lookahead
                FeatureLookbehind:    false, // No lookbehind
                FeatureNamedGroup:    true,  // Go has named groups
                FeatureAtomicGroup:   false, // No atomic groups
                FeatureConditional:   false, // No conditionals
                FeaturePossessive:    false, // No possessive quantifiers
                FeatureUnicodeClass:  true,  // Has unicode classes
                FeatureRecursion:     false, // No recursion
                FeatureBackreference: true,  // Supports backreferences
                FeatureNamedBackref:  true,  // Supports named backreferences
        }
        
        return supportedFeatures[feature]
}</span>

// TokenizeRegex breaks a regex pattern into meaningful tokens
func (g *GoFormat) TokenizeRegex(pattern string) []string <span class="cov8" title="1">{
        var tokens []string
        var currentToken strings.Builder
        
        for i := 0; i &lt; len(pattern); i++ </span><span class="cov8" title="1">{
                char := pattern[i]
                
                // Handle character classes
                if char == '[' </span><span class="cov8" title="1">{
                        if currentToken.Len() &gt; 0 </span><span class="cov0" title="0">{
                                tokens = append(tokens, currentToken.String())
                                currentToken.Reset()
                        }</span>
                        
                        <span class="cov8" title="1">end := FindClosingBracket(pattern, i)
                        if end &gt; i </span><span class="cov8" title="1">{
                                tokens = append(tokens, pattern[i:end+1])
                                i = end
                                continue</span>
                        }
                }
                
                // Handle special escape sequences
                <span class="cov8" title="1">if char == '\\' &amp;&amp; i+1 &lt; len(pattern) </span><span class="cov8" title="1">{
                        if currentToken.Len() &gt; 0 </span><span class="cov0" title="0">{
                                tokens = append(tokens, currentToken.String())
                                currentToken.Reset()
                        }</span>
                        <span class="cov8" title="1">tokens = append(tokens, pattern[i:i+2])
                        i++
                        continue</span>
                }
                
                // Handle curly brace quantifiers
                <span class="cov8" title="1">if char == '{' </span><span class="cov8" title="1">{
                        if currentToken.Len() &gt; 0 </span><span class="cov8" title="1">{
                                tokens = append(tokens, currentToken.String())
                                currentToken.Reset()
                        }</span>
                        
                        <span class="cov8" title="1">end := FindClosingCurlyBrace(pattern, i)
                        if end &gt; i </span><span class="cov8" title="1">{
                                tokens = append(tokens, pattern[i:end+1])
                                i = end
                                continue</span>
                        }
                }
                
                // Handle simple quantifiers
                <span class="cov8" title="1">if char == '*' || char == '+' || char == '?' </span><span class="cov8" title="1">{
                        if currentToken.Len() &gt; 0 </span><span class="cov8" title="1">{
                                tokens = append(tokens, currentToken.String())
                                currentToken.Reset()
                        }</span>
                        <span class="cov8" title="1">tokens = append(tokens, string(char))
                        continue</span>
                }
                
                // Handle groups and named groups
                <span class="cov8" title="1">if char == '(' </span><span class="cov8" title="1">{
                        if currentToken.Len() &gt; 0 </span><span class="cov8" title="1">{
                                tokens = append(tokens, currentToken.String())
                                currentToken.Reset()
                        }</span>
                        
                        // Check for non-capturing and other special groups
                        <span class="cov8" title="1">if i+2 &lt; len(pattern) &amp;&amp; pattern[i+1] == '?' </span><span class="cov8" title="1">{
                                switch pattern[i+2] </span>{
                                case ':':<span class="cov8" title="1"> // (?:pattern) - non-capturing group
                                        tokens = append(tokens, "(?:")
                                        i += 2</span>
                                case '=':<span class="cov8" title="1"> // (?=pattern) - positive lookahead
                                        tokens = append(tokens, "(?=")
                                        i += 2</span>
                                case 'P':<span class="cov8" title="1"> // (?P&lt;name&gt;pattern) - named capturing group
                                        if i+3 &lt; len(pattern) &amp;&amp; pattern[i+3] == '&lt;' </span><span class="cov8" title="1">{
                                                endName := strings.IndexByte(pattern[i+4:], '&gt;')
                                                if endName &gt;= 0 </span><span class="cov8" title="1">{
                                                        endName += i + 4
                                                        tokens = append(tokens, pattern[i:endName+1])
                                                        i = endName
                                                }</span> else<span class="cov0" title="0"> {
                                                        tokens = append(tokens, string(char))
                                                }</span>
                                        } else<span class="cov0" title="0"> {
                                                tokens = append(tokens, string(char))
                                        }</span>
                                default:<span class="cov0" title="0">
                                        tokens = append(tokens, string(char))</span>
                                }
                                <span class="cov8" title="1">continue</span>
                        } else<span class="cov8" title="1"> {
                                tokens = append(tokens, string(char))
                                continue</span>
                        }
                }
                
                <span class="cov8" title="1">if char == ')' </span><span class="cov8" title="1">{
                        if currentToken.Len() &gt; 0 </span><span class="cov8" title="1">{
                                tokens = append(tokens, currentToken.String())
                                currentToken.Reset()
                        }</span>
                        <span class="cov8" title="1">tokens = append(tokens, string(char))
                        continue</span>
                }
                
                // Handle alternation
                <span class="cov8" title="1">if char == '|' </span><span class="cov8" title="1">{
                        if currentToken.Len() &gt; 0 </span><span class="cov8" title="1">{
                                tokens = append(tokens, currentToken.String())
                                currentToken.Reset()
                        }</span>
                        <span class="cov8" title="1">tokens = append(tokens, string(char))
                        continue</span>
                }
                
                // Handle anchors
                <span class="cov8" title="1">if char == '^' || char == '$' </span><span class="cov8" title="1">{
                        if currentToken.Len() &gt; 0 </span><span class="cov0" title="0">{
                                tokens = append(tokens, currentToken.String())
                                currentToken.Reset()
                        }</span>
                        <span class="cov8" title="1">tokens = append(tokens, string(char))
                        continue</span>
                }
                
                // Handle dot
                <span class="cov8" title="1">if char == '.' </span><span class="cov8" title="1">{
                        if currentToken.Len() &gt; 0 </span><span class="cov8" title="1">{
                                tokens = append(tokens, currentToken.String())
                                currentToken.Reset()
                        }</span>
                        <span class="cov8" title="1">tokens = append(tokens, string(char))
                        continue</span>
                }
                
                // Default case: add to current token
                <span class="cov8" title="1">currentToken.WriteByte(char)</span>
        }
        
        // Add the last token if any
        <span class="cov8" title="1">if currentToken.Len() &gt; 0 </span><span class="cov8" title="1">{
                tokens = append(tokens, currentToken.String())
        }</span>
        
        <span class="cov8" title="1">return tokens</span>
}

// ExplainToken provides a human-readable explanation for a regex token
func (g *GoFormat) ExplainToken(token string) string <span class="cov8" title="1">{
        switch </span>{
        case token == "^":<span class="cov8" title="1">
                return "Matches the start of a line"</span>
        case token == "$":<span class="cov8" title="1">
                return "Matches the end of a line"</span>
        case token == ".":<span class="cov8" title="1">
                return "Matches any single character except newline"</span>
        case token == "*":<span class="cov8" title="1">
                return "Matches 0 or more of the preceding element"</span>
        case token == "+":<span class="cov8" title="1">
                return "Matches 1 or more of the preceding element"</span>
        case token == "?":<span class="cov8" title="1">
                return "Matches 0 or 1 of the preceding element"</span>
        case token == "|":<span class="cov8" title="1">
                return "Acts as an OR operator - matches the expression before or after the |"</span>
        case token == "(":<span class="cov8" title="1">
                return "Start of a capturing group"</span>
        case token == ")":<span class="cov8" title="1">
                return "End of a capturing group"</span>
        case token == "(?:":<span class="cov8" title="1">
                return "Start of a non-capturing group - groups the expression but doesn't create a capture group"</span>
        case token == "(?=":<span class="cov8" title="1">
                return "Start of a positive lookahead - matches if the pattern inside matches, but doesn't consume characters"</span>
        case strings.HasPrefix(token, "(?P&lt;") &amp;&amp; strings.HasSuffix(token, "&gt;"):<span class="cov8" title="1">
                name := token[4 : len(token)-1]
                return fmt.Sprintf("Start of a named capturing group called '%s'", name)</span>
        case strings.HasPrefix(token, "[") &amp;&amp; strings.HasSuffix(token, "]"):<span class="cov8" title="1">
                if len(token) &gt; 2 &amp;&amp; token[1] == '^' </span><span class="cov8" title="1">{
                        return fmt.Sprintf("Matches any character NOT in the set: %s", token[2:len(token)-1])
                }</span>
                <span class="cov8" title="1">return fmt.Sprintf("Matches any character in the set: %s", token[1:len(token)-1])</span>
        case strings.HasPrefix(token, "\\"):<span class="cov8" title="1">
                return explainEscapeSequence(token)</span>
        case strings.HasPrefix(token, "{") &amp;&amp; strings.HasSuffix(token, "}"):<span class="cov8" title="1">
                content := token[1 : len(token)-1]
                if strings.Contains(content, ",") </span><span class="cov8" title="1">{
                        parts := strings.Split(content, ",")
                        if len(parts) == 2 </span><span class="cov8" title="1">{
                                if parts[1] == "" </span><span class="cov8" title="1">{
                                        return fmt.Sprintf("Matches at least %s occurrences of the preceding element", parts[0])
                                }</span>
                                <span class="cov8" title="1">return fmt.Sprintf("Matches between %s and %s occurrences of the preceding element", parts[0], parts[1])</span>
                        }
                }
                <span class="cov8" title="1">return fmt.Sprintf("Matches exactly %s occurrences of the preceding element", content)</span>
        default:<span class="cov8" title="1">
                if len(token) == 1 </span><span class="cov8" title="1">{
                        return fmt.Sprintf("Matches the character '%s' literally", token)
                }</span>
                <span class="cov8" title="1">return fmt.Sprintf("Matches the string '%s' literally", token)</span>
        }
}

// explainEscapeSequence explains common regex escape sequences
func explainEscapeSequence(sequence string) string <span class="cov8" title="1">{
        if len(sequence) &lt; 2 </span><span class="cov0" title="0">{
                return "Invalid escape sequence"
        }</span>
        
        <span class="cov8" title="1">switch sequence[1] </span>{
        case 'd':<span class="cov8" title="1">
                return "Matches any digit (0-9)"</span>
        case 'D':<span class="cov0" title="0">
                return "Matches any non-digit character"</span>
        case 'w':<span class="cov8" title="1">
                return "Matches any word character (alphanumeric plus underscore)"</span>
        case 'W':<span class="cov0" title="0">
                return "Matches any non-word character"</span>
        case 's':<span class="cov8" title="1">
                return "Matches any whitespace character (space, tab, newline, etc.)"</span>
        case 'S':<span class="cov0" title="0">
                return "Matches any non-whitespace character"</span>
        case 'b':<span class="cov0" title="0">
                return "Matches a word boundary"</span>
        case 'B':<span class="cov0" title="0">
                return "Matches a non-word boundary"</span>
        case 'A':<span class="cov0" title="0">
                return "Matches the start of the string"</span>
        case 'z':<span class="cov0" title="0">
                return "Matches the end of the string"</span>
        case 'n':<span class="cov0" title="0">
                return "Matches a newline character"</span>
        case 't':<span class="cov0" title="0">
                return "Matches a tab character"</span>
        case 'r':<span class="cov0" title="0">
                return "Matches a carriage return character"</span>
        case 'f':<span class="cov0" title="0">
                return "Matches a form feed character"</span>
        case 'v':<span class="cov0" title="0">
                return "Matches a vertical tab character"</span>
        case '0':<span class="cov0" title="0">
                return "Matches a null character"</span>
        default:<span class="cov0" title="0">
                return fmt.Sprintf("Matches the character '%c' literally", sequence[1])</span>
        }
} </pre>
		
		<pre class="file" id="file4" style="display: none">package format

import (
        "fmt"
        "strings"
)

// JsFormat implements the RegexFormat interface for JavaScript RegExp
type JsFormat struct{}

// NewJsFormat creates a new JavaScript format implementation
func NewJsFormat() RegexFormat <span class="cov8" title="1">{
        return &amp;JsFormat{}
}</span>

// Name returns the descriptive name of the format
func (j *JsFormat) Name() string <span class="cov8" title="1">{
        return "JavaScript RegExp"
}</span>

// HasFeature checks if this format supports a specific regex feature
func (j *JsFormat) HasFeature(feature string) bool <span class="cov8" title="1">{
        supportedFeatures := map[string]bool{
                FeatureLookahead:     true,
                FeatureLookbehind:    true,  // Only in newer JS engines
                FeatureNamedGroup:    true,  // Only in newer JS engines
                FeatureAtomicGroup:   false,
                FeatureConditional:   false,
                FeaturePossessive:    false,
                FeatureUnicodeClass:  true,  // With /u flag
                FeatureRecursion:     false,
                FeatureBackreference: true,
                FeatureNamedBackref:  true,  // Only in newer JS engines
        }
        
        return supportedFeatures[feature]
}</span>

// TokenizeRegex breaks a regex pattern into meaningful tokens
func (j *JsFormat) TokenizeRegex(pattern string) []string <span class="cov8" title="1">{
        var tokens []string
        var currentToken strings.Builder
        
        // Check for regex flags at the end
        flags := ""
        if len(pattern) &gt; 2 &amp;&amp; pattern[0] == '/' </span><span class="cov8" title="1">{
                lastSlashPos := strings.LastIndex(pattern, "/")
                if lastSlashPos &gt; 0 &amp;&amp; lastSlashPos &lt; len(pattern)-1 </span><span class="cov8" title="1">{
                        flags = pattern[lastSlashPos+1:]
                        pattern = pattern[1:lastSlashPos]
                        
                        // Add flags explanation as first token
                        if len(flags) &gt; 0 </span><span class="cov8" title="1">{
                                tokens = append(tokens, "/"+flags)
                        }</span>
                } else<span class="cov0" title="0"> if pattern[0] == '/' &amp;&amp; pattern[len(pattern)-1] == '/' </span><span class="cov0" title="0">{
                        // No flags, but has delimiters
                        pattern = pattern[1 : len(pattern)-1]
                }</span>
        }
        
        <span class="cov8" title="1">for i := 0; i &lt; len(pattern); i++ </span><span class="cov8" title="1">{
                char := pattern[i]
                
                // Handle character classes
                if char == '[' </span><span class="cov8" title="1">{
                        if currentToken.Len() &gt; 0 </span><span class="cov0" title="0">{
                                tokens = append(tokens, currentToken.String())
                                currentToken.Reset()
                        }</span>
                        
                        <span class="cov8" title="1">end := FindClosingBracket(pattern, i)
                        if end &gt; i </span><span class="cov8" title="1">{
                                tokens = append(tokens, pattern[i:end+1])
                                i = end
                                continue</span>
                        }
                }
                
                // Handle special escape sequences
                <span class="cov8" title="1">if char == '\\' &amp;&amp; i+1 &lt; len(pattern) </span><span class="cov8" title="1">{
                        if currentToken.Len() &gt; 0 </span><span class="cov8" title="1">{
                                tokens = append(tokens, currentToken.String())
                                currentToken.Reset()
                        }</span>
                        <span class="cov8" title="1">tokens = append(tokens, pattern[i:i+2])
                        i++
                        continue</span>
                }
                
                // Handle curly brace quantifiers
                <span class="cov8" title="1">if char == '{' </span><span class="cov8" title="1">{
                        if currentToken.Len() &gt; 0 </span><span class="cov8" title="1">{
                                tokens = append(tokens, currentToken.String())
                                currentToken.Reset()
                        }</span>
                        
                        <span class="cov8" title="1">end := FindClosingCurlyBrace(pattern, i)
                        if end &gt; i </span><span class="cov8" title="1">{
                                tokens = append(tokens, pattern[i:end+1])
                                i = end
                                continue</span>
                        }
                }
                
                // Handle simple quantifiers
                <span class="cov8" title="1">if char == '*' || char == '+' || char == '?' </span><span class="cov8" title="1">{
                        if currentToken.Len() &gt; 0 </span><span class="cov8" title="1">{
                                tokens = append(tokens, currentToken.String())
                                currentToken.Reset()
                        }</span>
                        
                        // Check for non-greedy quantifier
                        <span class="cov8" title="1">if i+1 &lt; len(pattern) &amp;&amp; pattern[i+1] == '?' </span><span class="cov8" title="1">{
                                tokens = append(tokens, string(char)+"?")
                                i++
                        }</span> else<span class="cov8" title="1"> {
                                tokens = append(tokens, string(char))
                        }</span>
                        <span class="cov8" title="1">continue</span>
                }
                
                // Handle groups
                <span class="cov8" title="1">if char == '(' </span><span class="cov8" title="1">{
                        if currentToken.Len() &gt; 0 </span><span class="cov8" title="1">{
                                tokens = append(tokens, currentToken.String())
                                currentToken.Reset()
                        }</span>
                        
                        // Check for non-capturing and other special groups
                        <span class="cov8" title="1">if i+2 &lt; len(pattern) &amp;&amp; pattern[i+1] == '?' </span><span class="cov8" title="1">{
                                switch pattern[i+2] </span>{
                                case ':':<span class="cov8" title="1"> // (?:pattern) - non-capturing group
                                        tokens = append(tokens, "(?:")
                                        i += 2</span>
                                case '=':<span class="cov8" title="1"> // (?=pattern) - positive lookahead
                                        tokens = append(tokens, "(?=")
                                        i += 2</span>
                                case '!':<span class="cov8" title="1"> // (?!pattern) - negative lookahead
                                        tokens = append(tokens, "(?!")
                                        i += 2</span>
                                case '&lt;':<span class="cov8" title="1"> // Could be lookbehind or named capture
                                        if i+3 &lt; len(pattern) </span><span class="cov8" title="1">{
                                                if pattern[i+3] == '=' </span><span class="cov8" title="1">{ // (?&lt;=pattern) - positive lookbehind
                                                        tokens = append(tokens, "(?&lt;=")
                                                        i += 3
                                                }</span> else<span class="cov8" title="1"> if pattern[i+3] == '!' </span><span class="cov8" title="1">{ // (?&lt;!pattern) - negative lookbehind
                                                        tokens = append(tokens, "(?&lt;!")
                                                        i += 3
                                                }</span> else<span class="cov8" title="1"> { // (?&lt;name&gt;pattern) - named capturing group
                                                        endName := strings.IndexByte(pattern[i+3:], '&gt;')
                                                        if endName &gt;= 0 </span><span class="cov8" title="1">{
                                                                endName += i + 3
                                                                tokens = append(tokens, pattern[i:endName+1])
                                                                i = endName
                                                        }</span> else<span class="cov0" title="0"> {
                                                                tokens = append(tokens, string(char))
                                                        }</span>
                                                }
                                        } else<span class="cov0" title="0"> {
                                                tokens = append(tokens, string(char))
                                        }</span>
                                default:<span class="cov0" title="0">
                                        tokens = append(tokens, string(char))</span>
                                }
                                <span class="cov8" title="1">continue</span>
                        } else<span class="cov8" title="1"> {
                                tokens = append(tokens, string(char))
                                continue</span>
                        }
                }
                
                <span class="cov8" title="1">if char == ')' </span><span class="cov8" title="1">{
                        if currentToken.Len() &gt; 0 </span><span class="cov8" title="1">{
                                tokens = append(tokens, currentToken.String())
                                currentToken.Reset()
                        }</span>
                        <span class="cov8" title="1">tokens = append(tokens, string(char))
                        continue</span>
                }
                
                // Handle alternation
                <span class="cov8" title="1">if char == '|' </span><span class="cov8" title="1">{
                        if currentToken.Len() &gt; 0 </span><span class="cov8" title="1">{
                                tokens = append(tokens, currentToken.String())
                                currentToken.Reset()
                        }</span>
                        <span class="cov8" title="1">tokens = append(tokens, string(char))
                        continue</span>
                }
                
                // Handle anchors
                <span class="cov8" title="1">if char == '^' || char == '$' </span><span class="cov8" title="1">{
                        if currentToken.Len() &gt; 0 </span><span class="cov0" title="0">{
                                tokens = append(tokens, currentToken.String())
                                currentToken.Reset()
                        }</span>
                        <span class="cov8" title="1">tokens = append(tokens, string(char))
                        continue</span>
                }
                
                // Handle dot
                <span class="cov8" title="1">if char == '.' </span><span class="cov8" title="1">{
                        if currentToken.Len() &gt; 0 </span><span class="cov0" title="0">{
                                tokens = append(tokens, currentToken.String())
                                currentToken.Reset()
                        }</span>
                        <span class="cov8" title="1">tokens = append(tokens, string(char))
                        continue</span>
                }
                
                // Default case: add to current token
                <span class="cov8" title="1">currentToken.WriteByte(char)</span>
        }
        
        // Add the last token if any
        <span class="cov8" title="1">if currentToken.Len() &gt; 0 </span><span class="cov8" title="1">{
                tokens = append(tokens, currentToken.String())
        }</span>
        
        <span class="cov8" title="1">return tokens</span>
}

// ExplainToken provides a human-readable explanation for a regex token
func (j *JsFormat) ExplainToken(token string) string <span class="cov8" title="1">{
        switch </span>{
        case strings.HasPrefix(token, "/"):<span class="cov8" title="1">
                return explainJsFlags(token[1:])</span>
        case token == "^":<span class="cov8" title="1">
                return "Matches the start of a line"</span>
        case token == "$":<span class="cov8" title="1">
                return "Matches the end of a line"</span>
        case token == ".":<span class="cov8" title="1">
                return "Matches any single character except newline"</span>
        case token == "*":<span class="cov8" title="1">
                return "Matches 0 or more of the preceding element (greedy)"</span>
        case token == "+":<span class="cov8" title="1">
                return "Matches 1 or more of the preceding element (greedy)"</span>
        case token == "?":<span class="cov8" title="1">
                return "Matches 0 or 1 of the preceding element (greedy)"</span>
        case token == "*?":<span class="cov8" title="1">
                return "Matches 0 or more of the preceding element (non-greedy)"</span>
        case token == "+?":<span class="cov8" title="1">
                return "Matches 1 or more of the preceding element (non-greedy)"</span>
        case token == "??":<span class="cov8" title="1">
                return "Matches 0 or 1 of the preceding element (non-greedy)"</span>
        case token == "|":<span class="cov8" title="1">
                return "Acts as an OR operator - matches the expression before or after the |"</span>
        case token == "(":<span class="cov8" title="1">
                return "Start of a capturing group"</span>
        case token == ")":<span class="cov8" title="1">
                return "End of a capturing group"</span>
        case token == "(?:":<span class="cov8" title="1">
                return "Start of a non-capturing group - groups the expression but doesn't create a capture group"</span>
        case token == "(?=":<span class="cov8" title="1">
                return "Start of a positive lookahead - matches if the pattern inside matches, but doesn't consume characters"</span>
        case token == "(?!":<span class="cov8" title="1">
                return "Start of a negative lookahead - matches if the pattern inside doesn't match, but doesn't consume characters"</span>
        case token == "(?&lt;=":<span class="cov8" title="1">
                return "Start of a positive lookbehind - matches if the pattern inside matches immediately before current position"</span>
        case token == "(?&lt;!":<span class="cov8" title="1">
                return "Start of a negative lookbehind - matches if the pattern inside doesn't match immediately before current position"</span>
        case strings.HasPrefix(token, "(?&lt;") &amp;&amp; strings.HasSuffix(token, "&gt;") &amp;&amp; !strings.Contains(token, "&lt;?") &amp;&amp; !strings.Contains(token, "&lt;!"):<span class="cov8" title="1">
                name := token[3 : len(token)-1]
                return fmt.Sprintf("Start of a named capturing group called '%s'", name)</span>
        case strings.HasPrefix(token, "[") &amp;&amp; strings.HasSuffix(token, "]"):<span class="cov8" title="1">
                if len(token) &gt; 2 &amp;&amp; token[1] == '^' </span><span class="cov8" title="1">{
                        return fmt.Sprintf("Matches any character NOT in the set: %s", token[2:len(token)-1])
                }</span>
                <span class="cov8" title="1">return fmt.Sprintf("Matches any character in the set: %s", token[1:len(token)-1])</span>
        case strings.HasPrefix(token, "\\"):<span class="cov8" title="1">
                return explainJsEscapeSequence(token)</span>
        case strings.HasPrefix(token, "{") &amp;&amp; strings.HasSuffix(token, "}"):<span class="cov8" title="1">
                content := token[1 : len(token)-1]
                if strings.Contains(content, ",") </span><span class="cov8" title="1">{
                        parts := strings.Split(content, ",")
                        if len(parts) == 2 </span><span class="cov8" title="1">{
                                if parts[1] == "" </span><span class="cov8" title="1">{
                                        return fmt.Sprintf("Matches at least %s occurrences of the preceding element", parts[0])
                                }</span>
                                <span class="cov8" title="1">return fmt.Sprintf("Matches between %s and %s occurrences of the preceding element", parts[0], parts[1])</span>
                        }
                }
                <span class="cov8" title="1">return fmt.Sprintf("Matches exactly %s occurrences of the preceding element", content)</span>
        default:<span class="cov8" title="1">
                if len(token) == 1 </span><span class="cov8" title="1">{
                        return fmt.Sprintf("Matches the character '%s' literally", token)
                }</span>
                <span class="cov8" title="1">return fmt.Sprintf("Matches the string '%s' literally", token)</span>
        }
}

// explainJsFlags explains JavaScript RegExp flags
func explainJsFlags(flags string) string <span class="cov8" title="1">{
        if flags == "" </span><span class="cov0" title="0">{
                return "No flags specified"
        }</span>
        
        <span class="cov8" title="1">var explanations []string
        for _, flag := range flags </span><span class="cov8" title="1">{
                switch flag </span>{
                case 'g':<span class="cov8" title="1">
                        explanations = append(explanations, "g: Global search - find all matches rather than stopping after the first match")</span>
                case 'i':<span class="cov8" title="1">
                        explanations = append(explanations, "i: Case-insensitive search")</span>
                case 'm':<span class="cov8" title="1">
                        explanations = append(explanations, "m: Multi-line search - ^ and $ match start/end of each line")</span>
                case 's':<span class="cov8" title="1">
                        explanations = append(explanations, "s: Dot-all mode - the dot (.) matches newlines")</span>
                case 'u':<span class="cov8" title="1">
                        explanations = append(explanations, "u: Unicode mode - treat pattern as a sequence of Unicode code points")</span>
                case 'y':<span class="cov8" title="1">
                        explanations = append(explanations, "y: Sticky mode - matches only from the index indicated by the lastIndex property")</span>
                case 'd':<span class="cov0" title="0">
                        explanations = append(explanations, "d: Generate indices for substring matches")</span>
                default:<span class="cov0" title="0">
                        explanations = append(explanations, fmt.Sprintf("%c: Unknown flag", flag))</span>
                }
        }
        
        <span class="cov8" title="1">return "Flags: " + strings.Join(explanations, ", ")</span>
}

// explainJsEscapeSequence explains JavaScript-specific escape sequences
func explainJsEscapeSequence(sequence string) string <span class="cov8" title="1">{
        if len(sequence) &lt; 2 </span><span class="cov0" title="0">{
                return "Invalid escape sequence"
        }</span>
        
        <span class="cov8" title="1">switch sequence[1] </span>{
        case 'd':<span class="cov8" title="1">
                return "Matches any digit (0-9)"</span>
        case 'D':<span class="cov0" title="0">
                return "Matches any non-digit character"</span>
        case 'w':<span class="cov8" title="1">
                return "Matches any word character (alphanumeric plus underscore)"</span>
        case 'W':<span class="cov0" title="0">
                return "Matches any non-word character"</span>
        case 's':<span class="cov8" title="1">
                return "Matches any whitespace character (space, tab, newline, etc.)"</span>
        case 'S':<span class="cov0" title="0">
                return "Matches any non-whitespace character"</span>
        case 'b':<span class="cov0" title="0">
                return "Matches a word boundary"</span>
        case 'B':<span class="cov0" title="0">
                return "Matches a non-word boundary"</span>
        case 'n':<span class="cov0" title="0">
                return "Matches a newline character"</span>
        case 't':<span class="cov0" title="0">
                return "Matches a tab character"</span>
        case 'r':<span class="cov0" title="0">
                return "Matches a carriage return character"</span>
        case 'f':<span class="cov0" title="0">
                return "Matches a form feed character"</span>
        case 'v':<span class="cov0" title="0">
                return "Matches a vertical tab character"</span>
        case '0':<span class="cov0" title="0">
                return "Matches a null character"</span>
        case 'k':<span class="cov0" title="0">
                if len(sequence) &gt; 2 &amp;&amp; sequence[2] == '&lt;' </span><span class="cov0" title="0">{
                        end := strings.IndexByte(sequence[3:], '&gt;')
                        if end &gt;= 0 </span><span class="cov0" title="0">{
                                name := sequence[3 : 3+end]
                                return fmt.Sprintf("Backreference to the named group '%s'", name)
                        }</span>
                }
                <span class="cov0" title="0">return "Invalid named backreference"</span>
        case '1', '2', '3', '4', '5', '6', '7', '8', '9':<span class="cov0" title="0">
                return fmt.Sprintf("Backreference to capturing group %c", sequence[1])</span>
        case 'p', 'P':<span class="cov0" title="0">
                if len(sequence) &gt; 2 &amp;&amp; sequence[2] == '{' </span><span class="cov0" title="0">{
                        end := strings.IndexByte(sequence[3:], '}')
                        if end &gt;= 0 </span><span class="cov0" title="0">{
                                name := sequence[3 : 3+end]
                                if sequence[1] == 'p' </span><span class="cov0" title="0">{
                                        return fmt.Sprintf("Matches a character with the unicode property '%s' (requires u flag)", name)
                                }</span> else<span class="cov0" title="0"> {
                                        return fmt.Sprintf("Matches a character without the unicode property '%s' (requires u flag)", name)
                                }</span>
                        }
                }
                <span class="cov0" title="0">return "Invalid unicode property"</span>
        case 'u':<span class="cov8" title="1">
                if len(sequence) &gt;= 6 &amp;&amp; isHexDigit(sequence[2]) &amp;&amp; isHexDigit(sequence[3]) &amp;&amp; isHexDigit(sequence[4]) &amp;&amp; isHexDigit(sequence[5]) </span><span class="cov8" title="1">{
                        return fmt.Sprintf("Matches the Unicode character U+%s", sequence[2:6])
                }</span>
                <span class="cov0" title="0">return "Invalid Unicode escape sequence"</span>
        case 'x':<span class="cov8" title="1">
                if len(sequence) &gt;= 4 &amp;&amp; isHexDigit(sequence[2]) &amp;&amp; isHexDigit(sequence[3]) </span><span class="cov8" title="1">{
                        return fmt.Sprintf("Matches the character with hex code %s", sequence[2:4])
                }</span>
                <span class="cov0" title="0">return "Invalid hexadecimal escape sequence"</span>
        default:<span class="cov0" title="0">
                return fmt.Sprintf("Matches the character '%c' literally", sequence[1])</span>
        }
}

// Helper function to check if a byte is a hex digit
func isHexDigit(b byte) bool <span class="cov8" title="1">{
        return (b &gt;= '0' &amp;&amp; b &lt;= '9') || (b &gt;= 'a' &amp;&amp; b &lt;= 'f') || (b &gt;= 'A' &amp;&amp; b &lt;= 'F')
}</span> </pre>
		
		<pre class="file" id="file5" style="display: none">package format

import (
        "fmt"
        "strings"
)

// PcreFormat implements the RegexFormat interface for PCRE regular expressions
type PcreFormat struct{}

// NewPcreFormat creates a new PCRE format implementation
func NewPcreFormat() RegexFormat <span class="cov8" title="1">{
        return &amp;PcreFormat{}
}</span>

// Name returns the descriptive name of the format
func (p *PcreFormat) Name() string <span class="cov8" title="1">{
        return "Perl Compatible Regular Expressions (PCRE)"
}</span>

// HasFeature checks if this format supports a specific regex feature
func (p *PcreFormat) HasFeature(feature string) bool <span class="cov8" title="1">{
        // PCRE supports almost all regex features
        supportedFeatures := map[string]bool{
                FeatureLookahead:     true,
                FeatureLookbehind:    true,
                FeatureNamedGroup:    true,
                FeatureAtomicGroup:   true,
                FeatureConditional:   true,
                FeaturePossessive:    true,
                FeatureUnicodeClass:  true,
                FeatureRecursion:     true,
                FeatureBackreference: true,
                FeatureNamedBackref:  true,
        }
        
        return supportedFeatures[feature]
}</span>

// TokenizeRegex breaks a regex pattern into meaningful tokens
func (p *PcreFormat) TokenizeRegex(pattern string) []string <span class="cov8" title="1">{
        var tokens []string
        var currentToken strings.Builder
        
        for i := 0; i &lt; len(pattern); i++ </span><span class="cov8" title="1">{
                char := pattern[i]
                
                // Handle character classes
                if char == '[' </span><span class="cov8" title="1">{
                        if currentToken.Len() &gt; 0 </span><span class="cov0" title="0">{
                                tokens = append(tokens, currentToken.String())
                                currentToken.Reset()
                        }</span>
                        
                        <span class="cov8" title="1">end := FindClosingBracket(pattern, i)
                        if end &gt; i </span><span class="cov8" title="1">{
                                tokens = append(tokens, pattern[i:end+1])
                                i = end
                                continue</span>
                        }
                }
                
                // Handle special escape sequences
                <span class="cov8" title="1">if char == '\\' &amp;&amp; i+1 &lt; len(pattern) </span><span class="cov8" title="1">{
                        if currentToken.Len() &gt; 0 </span><span class="cov8" title="1">{
                                tokens = append(tokens, currentToken.String())
                                currentToken.Reset()
                        }</span>
                        <span class="cov8" title="1">tokens = append(tokens, pattern[i:i+2])
                        i++
                        continue</span>
                }
                
                // Handle curly brace quantifiers
                <span class="cov8" title="1">if char == '{' </span><span class="cov8" title="1">{
                        if currentToken.Len() &gt; 0 </span><span class="cov8" title="1">{
                                tokens = append(tokens, currentToken.String())
                                currentToken.Reset()
                        }</span>
                        
                        <span class="cov8" title="1">end := FindClosingCurlyBrace(pattern, i)
                        if end &gt; i </span><span class="cov8" title="1">{
                                tokens = append(tokens, pattern[i:end+1])
                                i = end
                                continue</span>
                        }
                }
                
                // Handle simple quantifiers and possessive modifiers
                <span class="cov8" title="1">if char == '*' || char == '+' || char == '?' </span><span class="cov8" title="1">{
                        if currentToken.Len() &gt; 0 </span><span class="cov8" title="1">{
                                tokens = append(tokens, currentToken.String())
                                currentToken.Reset()
                        }</span>
                        
                        // Check for possessive quantifier
                        <span class="cov8" title="1">if i+1 &lt; len(pattern) &amp;&amp; pattern[i+1] == '+' </span><span class="cov8" title="1">{
                                tokens = append(tokens, string(char)+"+")
                                i++
                        }</span> else<span class="cov8" title="1"> {
                                tokens = append(tokens, string(char))
                        }</span>
                        <span class="cov8" title="1">continue</span>
                }
                
                // Handle groups and special assertions
                <span class="cov8" title="1">if char == '(' </span><span class="cov8" title="1">{
                        if currentToken.Len() &gt; 0 </span><span class="cov8" title="1">{
                                tokens = append(tokens, currentToken.String())
                                currentToken.Reset()
                        }</span>
                        
                        // Check for special groups
                        <span class="cov8" title="1">if i+2 &lt; len(pattern) &amp;&amp; pattern[i+1] == '?' </span><span class="cov8" title="1">{
                                switch pattern[i+2] </span>{
                                case ':':<span class="cov8" title="1"> // (?:pattern) - non-capturing group
                                        tokens = append(tokens, "(?:")
                                        i += 2</span>
                                case '=':<span class="cov8" title="1"> // (?=pattern) - positive lookahead
                                        tokens = append(tokens, "(?=")
                                        i += 2</span>
                                case '!':<span class="cov8" title="1"> // (?!pattern) - negative lookahead
                                        tokens = append(tokens, "(?!")
                                        i += 2</span>
                                case '&lt;':<span class="cov8" title="1"> // Could be lookbehind or named group
                                        if i+3 &lt; len(pattern) </span><span class="cov8" title="1">{
                                                if pattern[i+3] == '=' </span><span class="cov8" title="1">{ // (?&lt;=pattern) - positive lookbehind
                                                        tokens = append(tokens, "(?&lt;=")
                                                        i += 3
                                                }</span> else<span class="cov8" title="1"> if pattern[i+3] == '!' </span><span class="cov8" title="1">{ // (?&lt;!pattern) - negative lookbehind
                                                        tokens = append(tokens, "(?&lt;!")
                                                        i += 3
                                                }</span> else<span class="cov8" title="1"> { // (?&lt;name&gt;pattern) - named capturing group
                                                        endName := strings.IndexByte(pattern[i+3:], '&gt;')
                                                        if endName &gt;= 0 </span><span class="cov8" title="1">{
                                                                endName += i + 3
                                                                tokens = append(tokens, pattern[i:endName+1])
                                                                i = endName
                                                        }</span> else<span class="cov0" title="0"> {
                                                                tokens = append(tokens, string(char))
                                                        }</span>
                                                }
                                        } else<span class="cov0" title="0"> {
                                                tokens = append(tokens, string(char))
                                        }</span>
                                case '&gt;':<span class="cov8" title="1"> // (?&gt;pattern) - atomic group
                                        tokens = append(tokens, "(?&gt;")
                                        i += 2</span>
                                case 'P':<span class="cov8" title="1"> // (?P&lt;name&gt;pattern) - another named group syntax
                                        if i+3 &lt; len(pattern) &amp;&amp; pattern[i+3] == '&lt;' </span><span class="cov8" title="1">{
                                                endName := strings.IndexByte(pattern[i+4:], '&gt;')
                                                if endName &gt;= 0 </span><span class="cov8" title="1">{
                                                        endName += i + 4
                                                        tokens = append(tokens, pattern[i:endName+1])
                                                        i = endName
                                                }</span> else<span class="cov0" title="0"> {
                                                        tokens = append(tokens, string(char))
                                                }</span>
                                        } else<span class="cov0" title="0"> {
                                                tokens = append(tokens, string(char))
                                        }</span>
                                default:<span class="cov0" title="0">
                                        tokens = append(tokens, string(char))</span>
                                }
                                <span class="cov8" title="1">continue</span>
                        } else<span class="cov8" title="1"> {
                                tokens = append(tokens, string(char))
                                continue</span>
                        }
                }
                
                <span class="cov8" title="1">if char == ')' </span><span class="cov8" title="1">{
                        if currentToken.Len() &gt; 0 </span><span class="cov8" title="1">{
                                tokens = append(tokens, currentToken.String())
                                currentToken.Reset()
                        }</span>
                        <span class="cov8" title="1">tokens = append(tokens, string(char))
                        continue</span>
                }
                
                // Handle alternation
                <span class="cov8" title="1">if char == '|' </span><span class="cov8" title="1">{
                        if currentToken.Len() &gt; 0 </span><span class="cov8" title="1">{
                                tokens = append(tokens, currentToken.String())
                                currentToken.Reset()
                        }</span>
                        <span class="cov8" title="1">tokens = append(tokens, string(char))
                        continue</span>
                }
                
                // Handle anchors
                <span class="cov8" title="1">if char == '^' || char == '$' </span><span class="cov8" title="1">{
                        if currentToken.Len() &gt; 0 </span><span class="cov0" title="0">{
                                tokens = append(tokens, currentToken.String())
                                currentToken.Reset()
                        }</span>
                        <span class="cov8" title="1">tokens = append(tokens, string(char))
                        continue</span>
                }
                
                // Handle dot
                <span class="cov8" title="1">if char == '.' </span><span class="cov8" title="1">{
                        if currentToken.Len() &gt; 0 </span><span class="cov8" title="1">{
                                tokens = append(tokens, currentToken.String())
                                currentToken.Reset()
                        }</span>
                        <span class="cov8" title="1">tokens = append(tokens, string(char))
                        continue</span>
                }
                
                // Default case: add to current token
                <span class="cov8" title="1">currentToken.WriteByte(char)</span>
        }
        
        // Add the last token if any
        <span class="cov8" title="1">if currentToken.Len() &gt; 0 </span><span class="cov8" title="1">{
                tokens = append(tokens, currentToken.String())
        }</span>
        
        <span class="cov8" title="1">return tokens</span>
}

// ExplainToken provides a human-readable explanation for a regex token
func (p *PcreFormat) ExplainToken(token string) string <span class="cov8" title="1">{
        switch </span>{
        case token == "^":<span class="cov8" title="1">
                return "Matches the start of a line"</span>
        case token == "$":<span class="cov8" title="1">
                return "Matches the end of a line"</span>
        case token == ".":<span class="cov8" title="1">
                return "Matches any single character except newline"</span>
        case token == "*":<span class="cov8" title="1">
                return "Matches 0 or more of the preceding element"</span>
        case token == "+":<span class="cov8" title="1">
                return "Matches 1 or more of the preceding element"</span>
        case token == "?":<span class="cov8" title="1">
                return "Matches 0 or 1 of the preceding element"</span>
        case token == "*+":<span class="cov8" title="1">
                return "Possessive match of 0 or more of the preceding element (never gives up the match)"</span>
        case token == "++":<span class="cov8" title="1">
                return "Possessive match of 1 or more of the preceding element (never gives up the match)"</span>
        case token == "?+":<span class="cov8" title="1">
                return "Possessive match of 0 or 1 of the preceding element (never gives up the match)"</span>
        case token == "|":<span class="cov8" title="1">
                return "Acts as an OR operator - matches the expression before or after the |"</span>
        case token == "(":<span class="cov8" title="1">
                return "Start of a capturing group"</span>
        case token == ")":<span class="cov8" title="1">
                return "End of a capturing group"</span>
        case token == "(?:":<span class="cov8" title="1">
                return "Start of a non-capturing group - groups the expression but doesn't create a capture group"</span>
        case token == "(?=":<span class="cov8" title="1">
                return "Start of a positive lookahead - matches if the pattern inside matches, but doesn't consume characters"</span>
        case token == "(?!":<span class="cov8" title="1">
                return "Start of a negative lookahead - matches if the pattern inside doesn't match, but doesn't consume characters"</span>
        case token == "(?&lt;=":<span class="cov8" title="1">
                return "Start of a positive lookbehind - matches if the pattern inside matches immediately before current position"</span>
        case token == "(?&lt;!":<span class="cov8" title="1">
                return "Start of a negative lookbehind - matches if the pattern inside doesn't match immediately before current position"</span>
        case token == "(?&gt;":<span class="cov8" title="1">
                return "Start of an atomic group - once the group matches, the regex engine doesn't backtrack into it"</span>
        case strings.HasPrefix(token, "(?&lt;") &amp;&amp; strings.HasSuffix(token, "&gt;") &amp;&amp; !strings.Contains(token, "&lt;?") &amp;&amp; !strings.Contains(token, "&lt;!"):<span class="cov8" title="1">
                name := token[3 : len(token)-1]
                return fmt.Sprintf("Start of a named capturing group called '%s'", name)</span>
        case strings.HasPrefix(token, "(?P&lt;") &amp;&amp; strings.HasSuffix(token, "&gt;"):<span class="cov8" title="1">
                name := token[4 : len(token)-1]
                return fmt.Sprintf("Start of a named capturing group called '%s'", name)</span>
        case strings.HasPrefix(token, "[") &amp;&amp; strings.HasSuffix(token, "]"):<span class="cov8" title="1">
                if len(token) &gt; 2 &amp;&amp; token[1] == '^' </span><span class="cov8" title="1">{
                        return fmt.Sprintf("Matches any character NOT in the set: %s", token[2:len(token)-1])
                }</span>
                <span class="cov8" title="1">return fmt.Sprintf("Matches any character in the set: %s", token[1:len(token)-1])</span>
        case strings.HasPrefix(token, "\\"):<span class="cov8" title="1">
                return explainPcreEscapeSequence(token)</span>
        case strings.HasPrefix(token, "{") &amp;&amp; strings.HasSuffix(token, "}"):<span class="cov8" title="1">
                content := token[1 : len(token)-1]
                if strings.Contains(content, ",") </span><span class="cov8" title="1">{
                        parts := strings.Split(content, ",")
                        if len(parts) == 2 </span><span class="cov8" title="1">{
                                if parts[1] == "" </span><span class="cov8" title="1">{
                                        return fmt.Sprintf("Matches at least %s occurrences of the preceding element", parts[0])
                                }</span>
                                <span class="cov8" title="1">return fmt.Sprintf("Matches between %s and %s occurrences of the preceding element", parts[0], parts[1])</span>
                        }
                }
                <span class="cov8" title="1">return fmt.Sprintf("Matches exactly %s occurrences of the preceding element", content)</span>
        default:<span class="cov8" title="1">
                if len(token) == 1 </span><span class="cov8" title="1">{
                        return fmt.Sprintf("Matches the character '%s' literally", token)
                }</span>
                <span class="cov8" title="1">return fmt.Sprintf("Matches the string '%s' literally", token)</span>
        }
}

// explainPcreEscapeSequence explains PCRE-specific escape sequences
func explainPcreEscapeSequence(sequence string) string <span class="cov8" title="1">{
        if len(sequence) &lt; 2 </span><span class="cov0" title="0">{
                return "Invalid escape sequence"
        }</span>
        
        <span class="cov8" title="1">switch sequence[1] </span>{
        case 'd':<span class="cov8" title="1">
                return "Matches any digit (0-9)"</span>
        case 'D':<span class="cov0" title="0">
                return "Matches any non-digit character"</span>
        case 'w':<span class="cov8" title="1">
                return "Matches any word character (alphanumeric plus underscore)"</span>
        case 'W':<span class="cov0" title="0">
                return "Matches any non-word character"</span>
        case 's':<span class="cov8" title="1">
                return "Matches any whitespace character (space, tab, newline, etc.)"</span>
        case 'S':<span class="cov0" title="0">
                return "Matches any non-whitespace character"</span>
        case 'b':<span class="cov0" title="0">
                return "Matches a word boundary"</span>
        case 'B':<span class="cov0" title="0">
                return "Matches a non-word boundary"</span>
        case 'A':<span class="cov0" title="0">
                return "Matches the start of the string"</span>
        case 'Z':<span class="cov0" title="0">
                return "Matches the end of the string or before the final newline"</span>
        case 'z':<span class="cov0" title="0">
                return "Matches the absolute end of the string"</span>
        case 'G':<span class="cov8" title="1">
                return "Matches the position where the previous match ended"</span>
        case 'n':<span class="cov0" title="0">
                return "Matches a newline character"</span>
        case 't':<span class="cov0" title="0">
                return "Matches a tab character"</span>
        case 'r':<span class="cov0" title="0">
                return "Matches a carriage return character"</span>
        case 'f':<span class="cov0" title="0">
                return "Matches a form feed character"</span>
        case 'v':<span class="cov0" title="0">
                return "Matches a vertical tab character"</span>
        case '0':<span class="cov0" title="0">
                return "Matches a null character"</span>
        case 'k':<span class="cov0" title="0">
                if len(sequence) &gt; 2 &amp;&amp; sequence[2] == '&lt;' </span><span class="cov0" title="0">{
                        end := strings.IndexByte(sequence[3:], '&gt;')
                        if end &gt;= 0 </span><span class="cov0" title="0">{
                                name := sequence[3 : 3+end]
                                return fmt.Sprintf("Backreference to the named group '%s'", name)
                        }</span>
                }
                <span class="cov0" title="0">return "Invalid named backreference"</span>
        case '1', '2', '3', '4', '5', '6', '7', '8', '9':<span class="cov0" title="0">
                return fmt.Sprintf("Backreference to capturing group %c", sequence[1])</span>
        case 'p', 'P':<span class="cov0" title="0">
                if len(sequence) &gt; 2 &amp;&amp; sequence[2] == '{' </span><span class="cov0" title="0">{
                        end := strings.IndexByte(sequence[3:], '}')
                        if end &gt;= 0 </span><span class="cov0" title="0">{
                                name := sequence[3 : 3+end]
                                if sequence[1] == 'p' </span><span class="cov0" title="0">{
                                        return fmt.Sprintf("Matches a character with the unicode property '%s'", name)
                                }</span> else<span class="cov0" title="0"> {
                                        return fmt.Sprintf("Matches a character without the unicode property '%s'", name)
                                }</span>
                        }
                }
                <span class="cov0" title="0">return "Invalid unicode property"</span>
        case 'Q':<span class="cov8" title="1">
                return "Start of a quoted sequence (everything until \\E is treated as a literal)"</span>
        case 'E':<span class="cov8" title="1">
                return "End of a quoted sequence"</span>
        default:<span class="cov0" title="0">
                return fmt.Sprintf("Matches the character '%c' literally", sequence[1])</span>
        }
} </pre>
		
		<pre class="file" id="file6" style="display: none">package format

import (
        "fmt"
        "strings"
)

// PosixFormat implements the RegexFormat interface for POSIX Extended Regular Expressions
type PosixFormat struct{}

// NewPosixFormat creates a new POSIX format implementation
func NewPosixFormat() RegexFormat <span class="cov8" title="1">{
        return &amp;PosixFormat{}
}</span>

// Name returns the descriptive name of the format
func (p *PosixFormat) Name() string <span class="cov0" title="0">{
        return "POSIX Extended Regular Expressions"
}</span>

// HasFeature checks if this format supports a specific regex feature
func (p *PosixFormat) HasFeature(feature string) bool <span class="cov0" title="0">{
        // POSIX ERE has limited features
        supportedFeatures := map[string]bool{
                FeatureLookahead:     false,
                FeatureLookbehind:    false,
                FeatureNamedGroup:    false,
                FeatureAtomicGroup:   false,
                FeatureConditional:   false,
                FeaturePossessive:    false,
                FeatureUnicodeClass:  false,
                FeatureRecursion:     false,
                FeatureBackreference: true,
                FeatureNamedBackref:  false,
        }
        
        return supportedFeatures[feature]
}</span>

// TokenizeRegex breaks a regex pattern into meaningful tokens
func (p *PosixFormat) TokenizeRegex(pattern string) []string <span class="cov0" title="0">{
        var tokens []string
        var currentToken strings.Builder
        
        for i := 0; i &lt; len(pattern); i++ </span><span class="cov0" title="0">{
                char := pattern[i]
                
                // Handle character classes
                if char == '[' </span><span class="cov0" title="0">{
                        if currentToken.Len() &gt; 0 </span><span class="cov0" title="0">{
                                tokens = append(tokens, currentToken.String())
                                currentToken.Reset()
                        }</span>
                        
                        // Check for POSIX character classes
                        <span class="cov0" title="0">if i+2 &lt; len(pattern) &amp;&amp; pattern[i+1] == '[' &amp;&amp; pattern[i+2] == ':' </span><span class="cov0" title="0">{
                                end := strings.Index(pattern[i:], ":]")
                                if end &gt; 3 </span><span class="cov0" title="0">{ // [[:class:]]
                                        endBracket := FindClosingBracket(pattern, i)
                                        if endBracket &gt; i+end+2 </span><span class="cov0" title="0">{ // Make sure the bracket closes after the POSIX class
                                                tokens = append(tokens, pattern[i:endBracket+1])
                                                i = endBracket
                                                continue</span>
                                        }
                                }
                        }
                        
                        <span class="cov0" title="0">end := FindClosingBracket(pattern, i)
                        if end &gt; i </span><span class="cov0" title="0">{
                                tokens = append(tokens, pattern[i:end+1])
                                i = end
                                continue</span>
                        }
                }
                
                // Handle special escape sequences
                <span class="cov0" title="0">if char == '\\' &amp;&amp; i+1 &lt; len(pattern) </span><span class="cov0" title="0">{
                        if currentToken.Len() &gt; 0 </span><span class="cov0" title="0">{
                                tokens = append(tokens, currentToken.String())
                                currentToken.Reset()
                        }</span>
                        <span class="cov0" title="0">tokens = append(tokens, pattern[i:i+2])
                        i++
                        continue</span>
                }
                
                // Handle curly brace quantifiers
                <span class="cov0" title="0">if char == '{' </span><span class="cov0" title="0">{
                        if currentToken.Len() &gt; 0 </span><span class="cov0" title="0">{
                                tokens = append(tokens, currentToken.String())
                                currentToken.Reset()
                        }</span>
                        
                        <span class="cov0" title="0">end := FindClosingCurlyBrace(pattern, i)
                        if end &gt; i </span><span class="cov0" title="0">{
                                tokens = append(tokens, pattern[i:end+1])
                                i = end
                                continue</span>
                        }
                }
                
                // Handle simple quantifiers
                <span class="cov0" title="0">if char == '*' || char == '+' || char == '?' </span><span class="cov0" title="0">{
                        if currentToken.Len() &gt; 0 </span><span class="cov0" title="0">{
                                tokens = append(tokens, currentToken.String())
                                currentToken.Reset()
                        }</span>
                        <span class="cov0" title="0">tokens = append(tokens, string(char))
                        continue</span>
                }
                
                // Handle groups
                <span class="cov0" title="0">if char == '(' </span><span class="cov0" title="0">{
                        if currentToken.Len() &gt; 0 </span><span class="cov0" title="0">{
                                tokens = append(tokens, currentToken.String())
                                currentToken.Reset()
                        }</span>
                        <span class="cov0" title="0">tokens = append(tokens, string(char))
                        continue</span>
                }
                
                <span class="cov0" title="0">if char == ')' </span><span class="cov0" title="0">{
                        if currentToken.Len() &gt; 0 </span><span class="cov0" title="0">{
                                tokens = append(tokens, currentToken.String())
                                currentToken.Reset()
                        }</span>
                        <span class="cov0" title="0">tokens = append(tokens, string(char))
                        continue</span>
                }
                
                // Handle alternation
                <span class="cov0" title="0">if char == '|' </span><span class="cov0" title="0">{
                        if currentToken.Len() &gt; 0 </span><span class="cov0" title="0">{
                                tokens = append(tokens, currentToken.String())
                                currentToken.Reset()
                        }</span>
                        <span class="cov0" title="0">tokens = append(tokens, string(char))
                        continue</span>
                }
                
                // Handle anchors
                <span class="cov0" title="0">if char == '^' || char == '$' </span><span class="cov0" title="0">{
                        if currentToken.Len() &gt; 0 </span><span class="cov0" title="0">{
                                tokens = append(tokens, currentToken.String())
                                currentToken.Reset()
                        }</span>
                        <span class="cov0" title="0">tokens = append(tokens, string(char))
                        continue</span>
                }
                
                // Handle dot
                <span class="cov0" title="0">if char == '.' </span><span class="cov0" title="0">{
                        if currentToken.Len() &gt; 0 </span><span class="cov0" title="0">{
                                tokens = append(tokens, currentToken.String())
                                currentToken.Reset()
                        }</span>
                        <span class="cov0" title="0">tokens = append(tokens, string(char))
                        continue</span>
                }
                
                // Default case: add to current token
                <span class="cov0" title="0">currentToken.WriteByte(char)</span>
        }
        
        // Add the last token if any
        <span class="cov0" title="0">if currentToken.Len() &gt; 0 </span><span class="cov0" title="0">{
                tokens = append(tokens, currentToken.String())
        }</span>
        
        <span class="cov0" title="0">return tokens</span>
}

// ExplainToken provides a human-readable explanation for a regex token
func (p *PosixFormat) ExplainToken(token string) string <span class="cov0" title="0">{
        switch </span>{
        case token == "^":<span class="cov0" title="0">
                return "Matches the start of a line"</span>
        case token == "$":<span class="cov0" title="0">
                return "Matches the end of a line"</span>
        case token == ".":<span class="cov0" title="0">
                return "Matches any single character"</span>
        case token == "*":<span class="cov0" title="0">
                return "Matches 0 or more of the preceding element"</span>
        case token == "+":<span class="cov0" title="0">
                return "Matches 1 or more of the preceding element"</span>
        case token == "?":<span class="cov0" title="0">
                return "Matches 0 or 1 of the preceding element"</span>
        case token == "|":<span class="cov0" title="0">
                return "Acts as an OR operator - matches the expression before or after the |"</span>
        case token == "(":<span class="cov0" title="0">
                return "Start of a capturing group"</span>
        case token == ")":<span class="cov0" title="0">
                return "End of a capturing group"</span>
        case strings.HasPrefix(token, "[") &amp;&amp; strings.HasSuffix(token, "]"):<span class="cov0" title="0">
                if strings.Contains(token, "[[:") &amp;&amp; strings.Contains(token, ":]]") </span><span class="cov0" title="0">{
                        // Extract POSIX character class name
                        start := strings.Index(token, "[[:")
                        end := strings.Index(token, ":]]")
                        if start &gt;= 0 &amp;&amp; end &gt; start+3 </span><span class="cov0" title="0">{
                                className := token[start+3 : end]
                                return explainPosixCharClass(className)
                        }</span>
                }
                
                <span class="cov0" title="0">if len(token) &gt; 2 &amp;&amp; token[1] == '^' </span><span class="cov0" title="0">{
                        return fmt.Sprintf("Matches any character NOT in the set: %s", token[2:len(token)-1])
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("Matches any character in the set: %s", token[1:len(token)-1])</span>
        case strings.HasPrefix(token, "\\"):<span class="cov0" title="0">
                return explainPosixEscapeSequence(token)</span>
        case strings.HasPrefix(token, "{") &amp;&amp; strings.HasSuffix(token, "}"):<span class="cov0" title="0">
                content := token[1 : len(token)-1]
                if strings.Contains(content, ",") </span><span class="cov0" title="0">{
                        parts := strings.Split(content, ",")
                        if len(parts) == 2 </span><span class="cov0" title="0">{
                                if parts[1] == "" </span><span class="cov0" title="0">{
                                        return fmt.Sprintf("Matches at least %s occurrences of the preceding element", parts[0])
                                }</span>
                                <span class="cov0" title="0">return fmt.Sprintf("Matches between %s and %s occurrences of the preceding element", parts[0], parts[1])</span>
                        }
                }
                <span class="cov0" title="0">return fmt.Sprintf("Matches exactly %s occurrences of the preceding element", content)</span>
        default:<span class="cov0" title="0">
                if len(token) == 1 </span><span class="cov0" title="0">{
                        return fmt.Sprintf("Matches the character '%s' literally", token)
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("Matches the string '%s' literally", token)</span>
        }
}

// explainPosixCharClass explains POSIX character classes
func explainPosixCharClass(className string) string <span class="cov0" title="0">{
        switch className </span>{
        case "alnum":<span class="cov0" title="0">
                return "Matches any alphanumeric character (a-z, A-Z, 0-9)"</span>
        case "alpha":<span class="cov0" title="0">
                return "Matches any alphabetic character (a-z, A-Z)"</span>
        case "ascii":<span class="cov0" title="0">
                return "Matches any ASCII character (0-127)"</span>
        case "blank":<span class="cov0" title="0">
                return "Matches space and tab characters"</span>
        case "cntrl":<span class="cov0" title="0">
                return "Matches control characters"</span>
        case "digit":<span class="cov0" title="0">
                return "Matches decimal digits (0-9)"</span>
        case "graph":<span class="cov0" title="0">
                return "Matches visible characters (not including space)"</span>
        case "lower":<span class="cov0" title="0">
                return "Matches lowercase letters (a-z)"</span>
        case "print":<span class="cov0" title="0">
                return "Matches visible characters (including space)"</span>
        case "punct":<span class="cov0" title="0">
                return "Matches punctuation characters"</span>
        case "space":<span class="cov0" title="0">
                return "Matches whitespace characters (space, tab, newline, etc.)"</span>
        case "upper":<span class="cov0" title="0">
                return "Matches uppercase letters (A-Z)"</span>
        case "word":<span class="cov0" title="0">
                return "Matches word characters (alphanumeric plus underscore)"</span>
        case "xdigit":<span class="cov0" title="0">
                return "Matches hexadecimal digits (0-9, a-f, A-F)"</span>
        default:<span class="cov0" title="0">
                return fmt.Sprintf("Unknown POSIX character class '[:%s:]'", className)</span>
        }
}

// explainPosixEscapeSequence explains POSIX-specific escape sequences
func explainPosixEscapeSequence(sequence string) string <span class="cov0" title="0">{
        if len(sequence) &lt; 2 </span><span class="cov0" title="0">{
                return "Invalid escape sequence"
        }</span>
        
        // Most POSIX regex implementations support these common escape sequences
        <span class="cov0" title="0">switch sequence[1] </span>{
        case 'n':<span class="cov0" title="0">
                return "Matches a newline character"</span>
        case 't':<span class="cov0" title="0">
                return "Matches a tab character"</span>
        case 'r':<span class="cov0" title="0">
                return "Matches a carriage return character"</span>
        case '1', '2', '3', '4', '5', '6', '7', '8', '9':<span class="cov0" title="0">
                return fmt.Sprintf("Backreference to capturing group %c", sequence[1])</span>
        default:<span class="cov0" title="0">
                return fmt.Sprintf("Matches the character '%c' literally", sequence[1])</span>
        }
} </pre>
		
		<pre class="file" id="file7" style="display: none">package format

import (
        "fmt"
        "strings"
)

// PythonFormat implements the RegexFormat interface for Python regular expressions
type PythonFormat struct{}

// NewPythonFormat creates a new Python format implementation
func NewPythonFormat() RegexFormat <span class="cov8" title="1">{
        return &amp;PythonFormat{}
}</span>

// Name returns the descriptive name of the format
func (p *PythonFormat) Name() string <span class="cov0" title="0">{
        return "Python re"
}</span>

// HasFeature checks if this format supports a specific regex feature
func (p *PythonFormat) HasFeature(feature string) bool <span class="cov0" title="0">{
        supportedFeatures := map[string]bool{
                FeatureLookahead:     true,
                FeatureLookbehind:    true,
                FeatureNamedGroup:    true,
                FeatureAtomicGroup:   false,
                FeatureConditional:   false,
                FeaturePossessive:    false,
                FeatureUnicodeClass:  true,
                FeatureRecursion:     false,
                FeatureBackreference: true,
                FeatureNamedBackref:  true,
        }
        
        return supportedFeatures[feature]
}</span>

// TokenizeRegex breaks a regex pattern into meaningful tokens
func (p *PythonFormat) TokenizeRegex(pattern string) []string <span class="cov0" title="0">{
        var tokens []string
        var currentToken strings.Builder
        
        // Check for raw string marker and flags
        if len(pattern) &gt; 0 &amp;&amp; (pattern[0] == 'r' || pattern[0] == 'R') </span><span class="cov0" title="0">{
                if len(pattern) &gt; 1 &amp;&amp; (pattern[1] == '"' || pattern[1] == '\'') </span><span class="cov0" title="0">{
                        tokens = append(tokens, pattern[0:2])
                        pattern = pattern[2:]
                }</span>
        }
        
        // Handle inline flags at the beginning
        <span class="cov0" title="0">if len(pattern) &gt; 2 &amp;&amp; pattern[0] == '(' &amp;&amp; pattern[1] == '?' </span><span class="cov0" title="0">{
                flagEnd := strings.IndexByte(pattern, ')')
                if flagEnd &gt; 2 </span><span class="cov0" title="0">{
                        isFlag := true
                        for i := 2; i &lt; flagEnd; i++ </span><span class="cov0" title="0">{
                                if pattern[i] != 'a' &amp;&amp; pattern[i] != 'i' &amp;&amp; pattern[i] != 'L' &amp;&amp; 
                                   pattern[i] != 'm' &amp;&amp; pattern[i] != 's' &amp;&amp; pattern[i] != 'u' &amp;&amp; 
                                   pattern[i] != 'x' </span><span class="cov0" title="0">{
                                        isFlag = false
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">if isFlag </span><span class="cov0" title="0">{
                                tokens = append(tokens, pattern[0:flagEnd+1])
                                pattern = pattern[flagEnd+1:]
                        }</span>
                }
        }
        
        <span class="cov0" title="0">for i := 0; i &lt; len(pattern); i++ </span><span class="cov0" title="0">{
                char := pattern[i]
                
                // Handle character classes
                if char == '[' </span><span class="cov0" title="0">{
                        if currentToken.Len() &gt; 0 </span><span class="cov0" title="0">{
                                tokens = append(tokens, currentToken.String())
                                currentToken.Reset()
                        }</span>
                        
                        <span class="cov0" title="0">end := FindClosingBracket(pattern, i)
                        if end &gt; i </span><span class="cov0" title="0">{
                                tokens = append(tokens, pattern[i:end+1])
                                i = end
                                continue</span>
                        }
                }
                
                // Handle special escape sequences
                <span class="cov0" title="0">if char == '\\' &amp;&amp; i+1 &lt; len(pattern) </span><span class="cov0" title="0">{
                        if currentToken.Len() &gt; 0 </span><span class="cov0" title="0">{
                                tokens = append(tokens, currentToken.String())
                                currentToken.Reset()
                        }</span>
                        
                        // Python has some multi-character escape sequences
                        <span class="cov0" title="0">if i+2 &lt; len(pattern) &amp;&amp; pattern[i+1] == 'x' </span><span class="cov0" title="0">{
                                // \xhh - up to 2 hex digits
                                hexEnd := i + 4
                                if hexEnd &gt; len(pattern) </span><span class="cov0" title="0">{
                                        hexEnd = len(pattern)
                                }</span>
                                <span class="cov0" title="0">for j := i + 2; j &lt; hexEnd; j++ </span><span class="cov0" title="0">{
                                        if !isHexDigit(pattern[j]) </span><span class="cov0" title="0">{
                                                hexEnd = j
                                                break</span>
                                        }
                                }
                                <span class="cov0" title="0">tokens = append(tokens, pattern[i:hexEnd])
                                i = hexEnd - 1
                                continue</span>
                        } else<span class="cov0" title="0"> if i+2 &lt; len(pattern) &amp;&amp; pattern[i+1] == 'u' </span><span class="cov0" title="0">{
                                // \uxxxx - exactly 4 hex digits
                                if i+6 &lt;= len(pattern) &amp;&amp; isHexDigit(pattern[i+2]) &amp;&amp; isHexDigit(pattern[i+3]) &amp;&amp; 
                                   isHexDigit(pattern[i+4]) &amp;&amp; isHexDigit(pattern[i+5]) </span><span class="cov0" title="0">{
                                        tokens = append(tokens, pattern[i:i+6])
                                        i += 5
                                        continue</span>
                                }
                        } else<span class="cov0" title="0"> if i+2 &lt; len(pattern) &amp;&amp; pattern[i+1] == 'U' </span><span class="cov0" title="0">{
                                // \Uxxxxxxxx - exactly 8 hex digits
                                if i+10 &lt;= len(pattern) &amp;&amp; isHexDigit(pattern[i+2]) &amp;&amp; isHexDigit(pattern[i+3]) &amp;&amp; 
                                   isHexDigit(pattern[i+4]) &amp;&amp; isHexDigit(pattern[i+5]) &amp;&amp; isHexDigit(pattern[i+6]) &amp;&amp; 
                                   isHexDigit(pattern[i+7]) &amp;&amp; isHexDigit(pattern[i+8]) &amp;&amp; isHexDigit(pattern[i+9]) </span><span class="cov0" title="0">{
                                        tokens = append(tokens, pattern[i:i+10])
                                        i += 9
                                        continue</span>
                                }
                        } else<span class="cov0" title="0"> if i+2 &lt; len(pattern) &amp;&amp; pattern[i+1] == 'N' &amp;&amp; pattern[i+2] == '{' </span><span class="cov0" title="0">{
                                // \N{name} - Unicode character by name
                                end := strings.IndexByte(pattern[i+3:], '}')
                                if end &gt;= 0 </span><span class="cov0" title="0">{
                                        tokens = append(tokens, pattern[i:i+end+4])
                                        i += end + 3
                                        continue</span>
                                }
                        } else<span class="cov0" title="0"> {
                                tokens = append(tokens, pattern[i:i+2])
                                i++
                                continue</span>
                        }
                }
                
                // Handle curly brace quantifiers
                <span class="cov0" title="0">if char == '{' </span><span class="cov0" title="0">{
                        if currentToken.Len() &gt; 0 </span><span class="cov0" title="0">{
                                tokens = append(tokens, currentToken.String())
                                currentToken.Reset()
                        }</span>
                        
                        <span class="cov0" title="0">end := FindClosingCurlyBrace(pattern, i)
                        if end &gt; i </span><span class="cov0" title="0">{
                                tokens = append(tokens, pattern[i:end+1])
                                i = end
                                continue</span>
                        }
                }
                
                // Handle simple quantifiers
                <span class="cov0" title="0">if char == '*' || char == '+' || char == '?' </span><span class="cov0" title="0">{
                        if currentToken.Len() &gt; 0 </span><span class="cov0" title="0">{
                                tokens = append(tokens, currentToken.String())
                                currentToken.Reset()
                        }</span>
                        
                        // Check for non-greedy quantifier
                        <span class="cov0" title="0">if i+1 &lt; len(pattern) &amp;&amp; pattern[i+1] == '?' </span><span class="cov0" title="0">{
                                tokens = append(tokens, string(char)+"?")
                                i++
                        }</span> else<span class="cov0" title="0"> {
                                tokens = append(tokens, string(char))
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }
                
                // Handle groups
                <span class="cov0" title="0">if char == '(' </span><span class="cov0" title="0">{
                        if currentToken.Len() &gt; 0 </span><span class="cov0" title="0">{
                                tokens = append(tokens, currentToken.String())
                                currentToken.Reset()
                        }</span>
                        
                        // Check for non-capturing and other special groups
                        <span class="cov0" title="0">if i+2 &lt; len(pattern) &amp;&amp; pattern[i+1] == '?' </span><span class="cov0" title="0">{
                                switch pattern[i+2] </span>{
                                case ':':<span class="cov0" title="0"> // (?:pattern) - non-capturing group
                                        tokens = append(tokens, "(?:")
                                        i += 2</span>
                                case '=':<span class="cov0" title="0"> // (?=pattern) - positive lookahead
                                        tokens = append(tokens, "(?=")
                                        i += 2</span>
                                case '!':<span class="cov0" title="0"> // (?!pattern) - negative lookahead
                                        tokens = append(tokens, "(?!")
                                        i += 2</span>
                                case '&lt;':<span class="cov0" title="0"> // Could be lookbehind or named capture
                                        if i+3 &lt; len(pattern) </span><span class="cov0" title="0">{
                                                if pattern[i+3] == '=' </span><span class="cov0" title="0">{ // (?&lt;=pattern) - positive lookbehind
                                                        tokens = append(tokens, "(?&lt;=")
                                                        i += 3
                                                }</span> else<span class="cov0" title="0"> if pattern[i+3] == '!' </span><span class="cov0" title="0">{ // (?&lt;!pattern) - negative lookbehind
                                                        tokens = append(tokens, "(?&lt;!")
                                                        i += 3
                                                }</span> else<span class="cov0" title="0"> { // (?&lt;name&gt;pattern) - named capturing group
                                                        endName := strings.IndexByte(pattern[i+3:], '&gt;')
                                                        if endName &gt;= 0 </span><span class="cov0" title="0">{
                                                                endName += i + 3
                                                                tokens = append(tokens, pattern[i:endName+1])
                                                                i = endName
                                                        }</span> else<span class="cov0" title="0"> {
                                                                tokens = append(tokens, string(char))
                                                        }</span>
                                                }
                                        } else<span class="cov0" title="0"> {
                                                tokens = append(tokens, string(char))
                                        }</span>
                                case 'P':<span class="cov0" title="0"> // Python specific named group syntaxes
                                        if i+3 &lt; len(pattern) </span><span class="cov0" title="0">{
                                                if pattern[i+3] == '&lt;' </span><span class="cov0" title="0">{ // (?P&lt;name&gt;pattern) - Named group
                                                        endName := strings.IndexByte(pattern[i+4:], '&gt;')
                                                        if endName &gt;= 0 </span><span class="cov0" title="0">{
                                                                endName += i + 4
                                                                tokens = append(tokens, pattern[i:endName+1])
                                                                i = endName
                                                                continue</span>
                                                        }
                                                } else<span class="cov0" title="0"> if pattern[i+3] == '=' </span><span class="cov0" title="0">{ // (?P=name) - Named backreference
                                                        // Find the end of the name
                                                        j := i + 4
                                                        for j &lt; len(pattern) &amp;&amp; pattern[j] != ')' </span><span class="cov0" title="0">{
                                                                j++
                                                        }</span>
                                                        <span class="cov0" title="0">if j &lt; len(pattern) </span><span class="cov0" title="0">{
                                                                tokens = append(tokens, pattern[i:j+1])
                                                                i = j
                                                                continue</span>
                                                        }
                                                }
                                        }
                                        <span class="cov0" title="0">tokens = append(tokens, string(char))</span>
                                default:<span class="cov0" title="0">
                                        tokens = append(tokens, string(char))</span>
                                }
                                <span class="cov0" title="0">continue</span>
                        } else<span class="cov0" title="0"> {
                                tokens = append(tokens, string(char))
                                continue</span>
                        }
                }
                
                <span class="cov0" title="0">if char == ')' </span><span class="cov0" title="0">{
                        if currentToken.Len() &gt; 0 </span><span class="cov0" title="0">{
                                tokens = append(tokens, currentToken.String())
                                currentToken.Reset()
                        }</span>
                        <span class="cov0" title="0">tokens = append(tokens, string(char))
                        continue</span>
                }
                
                // Handle alternation
                <span class="cov0" title="0">if char == '|' </span><span class="cov0" title="0">{
                        if currentToken.Len() &gt; 0 </span><span class="cov0" title="0">{
                                tokens = append(tokens, currentToken.String())
                                currentToken.Reset()
                        }</span>
                        <span class="cov0" title="0">tokens = append(tokens, string(char))
                        continue</span>
                }
                
                // Handle anchors
                <span class="cov0" title="0">if char == '^' || char == '$' </span><span class="cov0" title="0">{
                        if currentToken.Len() &gt; 0 </span><span class="cov0" title="0">{
                                tokens = append(tokens, currentToken.String())
                                currentToken.Reset()
                        }</span>
                        <span class="cov0" title="0">tokens = append(tokens, string(char))
                        continue</span>
                }
                
                // Handle dot
                <span class="cov0" title="0">if char == '.' </span><span class="cov0" title="0">{
                        if currentToken.Len() &gt; 0 </span><span class="cov0" title="0">{
                                tokens = append(tokens, currentToken.String())
                                currentToken.Reset()
                        }</span>
                        <span class="cov0" title="0">tokens = append(tokens, string(char))
                        continue</span>
                }
                
                // Default case: add to current token
                <span class="cov0" title="0">currentToken.WriteByte(char)</span>
        }
        
        // Add the last token if any
        <span class="cov0" title="0">if currentToken.Len() &gt; 0 </span><span class="cov0" title="0">{
                tokens = append(tokens, currentToken.String())
        }</span>
        
        <span class="cov0" title="0">return tokens</span>
}

// ExplainToken provides a human-readable explanation for a regex token
func (p *PythonFormat) ExplainToken(token string) string <span class="cov0" title="0">{
        switch </span>{
        case strings.HasPrefix(token, "r'") || strings.HasPrefix(token, "r\"") || 
             strings.HasPrefix(token, "R'") || strings.HasPrefix(token, "R\""):<span class="cov0" title="0">
                return "Raw string marker - backslashes are treated literally"</span>
        case strings.HasPrefix(token, "(?") &amp;&amp; strings.HasSuffix(token, ")") &amp;&amp; len(token) &gt; 3:<span class="cov0" title="0">
                // Check for inline flags
                isFlag := true
                for i := 2; i &lt; len(token)-1; i++ </span><span class="cov0" title="0">{
                        if token[i] != 'a' &amp;&amp; token[i] != 'i' &amp;&amp; token[i] != 'L' &amp;&amp; 
                           token[i] != 'm' &amp;&amp; token[i] != 's' &amp;&amp; token[i] != 'u' &amp;&amp; 
                           token[i] != 'x' </span><span class="cov0" title="0">{
                                isFlag = false
                                break</span>
                        }
                }
                <span class="cov0" title="0">if isFlag </span><span class="cov0" title="0">{
                        return explainPythonFlags(token[2 : len(token)-1])
                }</span>
        case token == "^":<span class="cov0" title="0">
                return "Matches the start of a line"</span>
        case token == "$":<span class="cov0" title="0">
                return "Matches the end of a line"</span>
        case token == ".":<span class="cov0" title="0">
                return "Matches any single character except newline"</span>
        case token == "*":<span class="cov0" title="0">
                return "Matches 0 or more of the preceding element (greedy)"</span>
        case token == "+":<span class="cov0" title="0">
                return "Matches 1 or more of the preceding element (greedy)"</span>
        case token == "?":<span class="cov0" title="0">
                return "Matches 0 or 1 of the preceding element (greedy)"</span>
        case token == "*?":<span class="cov0" title="0">
                return "Matches 0 or more of the preceding element (non-greedy)"</span>
        case token == "+?":<span class="cov0" title="0">
                return "Matches 1 or more of the preceding element (non-greedy)"</span>
        case token == "??":<span class="cov0" title="0">
                return "Matches 0 or 1 of the preceding element (non-greedy)"</span>
        case token == "|":<span class="cov0" title="0">
                return "Acts as an OR operator - matches the expression before or after the |"</span>
        case token == "(":<span class="cov0" title="0">
                return "Start of a capturing group"</span>
        case token == ")":<span class="cov0" title="0">
                return "End of a capturing group"</span>
        case token == "(?:":<span class="cov0" title="0">
                return "Start of a non-capturing group - groups the expression but doesn't create a capture group"</span>
        case token == "(?=":<span class="cov0" title="0">
                return "Start of a positive lookahead - matches if the pattern inside matches, but doesn't consume characters"</span>
        case token == "(?!":<span class="cov0" title="0">
                return "Start of a negative lookahead - matches if the pattern inside doesn't match, but doesn't consume characters"</span>
        case token == "(?&lt;=":<span class="cov0" title="0">
                return "Start of a positive lookbehind - matches if the pattern inside matches immediately before current position"</span>
        case token == "(?&lt;!":<span class="cov0" title="0">
                return "Start of a negative lookbehind - matches if the pattern inside doesn't match immediately before current position"</span>
        case strings.HasPrefix(token, "(?P&lt;") &amp;&amp; strings.HasSuffix(token, "&gt;"):<span class="cov0" title="0">
                name := token[4 : len(token)-1]
                return fmt.Sprintf("Start of a named capturing group called '%s'", name)</span>
        case strings.HasPrefix(token, "(?P=") &amp;&amp; strings.HasSuffix(token, ")"):<span class="cov0" title="0">
                name := token[4 : len(token)-1]
                return fmt.Sprintf("Backreference to the named group '%s'", name)</span>
        case strings.HasPrefix(token, "[") &amp;&amp; strings.HasSuffix(token, "]"):<span class="cov0" title="0">
                if len(token) &gt; 2 &amp;&amp; token[1] == '^' </span><span class="cov0" title="0">{
                        return fmt.Sprintf("Matches any character NOT in the set: %s", token[2:len(token)-1])
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("Matches any character in the set: %s", token[1:len(token)-1])</span>
        case strings.HasPrefix(token, "\\"):<span class="cov0" title="0">
                return explainPythonEscapeSequence(token)</span>
        case strings.HasPrefix(token, "{") &amp;&amp; strings.HasSuffix(token, "}"):<span class="cov0" title="0">
                content := token[1 : len(token)-1]
                if strings.Contains(content, ",") </span><span class="cov0" title="0">{
                        parts := strings.Split(content, ",")
                        if len(parts) == 2 </span><span class="cov0" title="0">{
                                if parts[1] == "" </span><span class="cov0" title="0">{
                                        return fmt.Sprintf("Matches at least %s occurrences of the preceding element", parts[0])
                                }</span>
                                <span class="cov0" title="0">return fmt.Sprintf("Matches between %s and %s occurrences of the preceding element", parts[0], parts[1])</span>
                        }
                }
                <span class="cov0" title="0">return fmt.Sprintf("Matches exactly %s occurrences of the preceding element", content)</span>
        default:<span class="cov0" title="0">
                if len(token) == 1 </span><span class="cov0" title="0">{
                        return fmt.Sprintf("Matches the character '%s' literally", token)
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf("Matches the string '%s' literally", token)</span>
        }
        
        <span class="cov0" title="0">return fmt.Sprintf("Unknown token: %s", token)</span>
}

// explainPythonFlags explains Python regex flags
func explainPythonFlags(flags string) string <span class="cov0" title="0">{
        if flags == "" </span><span class="cov0" title="0">{
                return "No flags specified"
        }</span>
        
        <span class="cov0" title="0">var explanations []string
        for _, flag := range flags </span><span class="cov0" title="0">{
                switch flag </span>{
                case 'a':<span class="cov0" title="0">
                        explanations = append(explanations, "a: ASCII-only matching")</span>
                case 'i':<span class="cov0" title="0">
                        explanations = append(explanations, "i: Case-insensitive matching")</span>
                case 'L':<span class="cov0" title="0">
                        explanations = append(explanations, "L: Locale-dependent matching")</span>
                case 'm':<span class="cov0" title="0">
                        explanations = append(explanations, "m: Multi-line matching - ^ and $ match at line breaks")</span>
                case 's':<span class="cov0" title="0">
                        explanations = append(explanations, "s: Dot matches all - the dot (.) matches any character including newline")</span>
                case 'u':<span class="cov0" title="0">
                        explanations = append(explanations, "u: Unicode matching")</span>
                case 'x':<span class="cov0" title="0">
                        explanations = append(explanations, "x: Verbose - whitespace and comments in pattern are ignored")</span>
                default:<span class="cov0" title="0">
                        explanations = append(explanations, fmt.Sprintf("%c: Unknown flag", flag))</span>
                }
        }
        
        <span class="cov0" title="0">return "Flags: " + strings.Join(explanations, ", ")</span>
}

// explainPythonEscapeSequence explains Python-specific escape sequences
func explainPythonEscapeSequence(sequence string) string <span class="cov0" title="0">{
        if len(sequence) &lt; 2 </span><span class="cov0" title="0">{
                return "Invalid escape sequence"
        }</span>
        
        <span class="cov0" title="0">switch sequence[1] </span>{
        case 'A':<span class="cov0" title="0">
                return "Matches only at the start of the string"</span>
        case 'Z':<span class="cov0" title="0">
                return "Matches only at the end of the string"</span>
        case 'd':<span class="cov0" title="0">
                return "Matches any decimal digit (0-9)"</span>
        case 'D':<span class="cov0" title="0">
                return "Matches any non-digit character"</span>
        case 's':<span class="cov0" title="0">
                return "Matches any whitespace character (space, tab, newline, etc.)"</span>
        case 'S':<span class="cov0" title="0">
                return "Matches any non-whitespace character"</span>
        case 'w':<span class="cov0" title="0">
                return "Matches any alphanumeric character (including underscore)"</span>
        case 'W':<span class="cov0" title="0">
                return "Matches any non-alphanumeric character"</span>
        case 'b':<span class="cov0" title="0">
                return "Matches a word boundary"</span>
        case 'B':<span class="cov0" title="0">
                return "Matches a non-word boundary"</span>
        case 'n':<span class="cov0" title="0">
                return "Matches a newline character"</span>
        case 't':<span class="cov0" title="0">
                return "Matches a tab character"</span>
        case 'r':<span class="cov0" title="0">
                return "Matches a carriage return character"</span>
        case 'f':<span class="cov0" title="0">
                return "Matches a form feed character"</span>
        case 'v':<span class="cov0" title="0">
                return "Matches a vertical tab character"</span>
        case 'a':<span class="cov0" title="0">
                return "Matches a bell (BEL) character"</span>
        case '1', '2', '3', '4', '5', '6', '7', '8', '9':<span class="cov0" title="0">
                return fmt.Sprintf("Backreference to capturing group %c", sequence[1])</span>
        case 'g':<span class="cov0" title="0">
                if len(sequence) &gt; 3 &amp;&amp; sequence[2] == '&lt;' </span><span class="cov0" title="0">{
                        end := strings.IndexByte(sequence[3:], '&gt;')
                        if end &gt;= 0 </span><span class="cov0" title="0">{
                                name := sequence[3 : 3+end]
                                return fmt.Sprintf("Backreference to the named group '%s'", name)
                        }</span>
                }
                <span class="cov0" title="0">return "Invalid named backreference"</span>
        case 'x':<span class="cov0" title="0">
                if len(sequence) &gt;= 4 &amp;&amp; isHexDigit(sequence[2]) &amp;&amp; isHexDigit(sequence[3]) </span><span class="cov0" title="0">{
                        return fmt.Sprintf("Matches the character with hex code %s", sequence[2:4])
                }</span>
                <span class="cov0" title="0">return "Invalid hexadecimal escape sequence"</span>
        case 'u':<span class="cov0" title="0">
                if len(sequence) &gt;= 6 &amp;&amp; isHexDigit(sequence[2]) &amp;&amp; isHexDigit(sequence[3]) &amp;&amp; 
                   isHexDigit(sequence[4]) &amp;&amp; isHexDigit(sequence[5]) </span><span class="cov0" title="0">{
                        return fmt.Sprintf("Matches the Unicode character U+%s", sequence[2:6])
                }</span>
                <span class="cov0" title="0">return "Invalid Unicode escape sequence"</span>
        case 'U':<span class="cov0" title="0">
                if len(sequence) &gt;= 10 &amp;&amp; isHexDigit(sequence[2]) &amp;&amp; isHexDigit(sequence[3]) &amp;&amp; 
                   isHexDigit(sequence[4]) &amp;&amp; isHexDigit(sequence[5]) &amp;&amp; isHexDigit(sequence[6]) &amp;&amp; 
                   isHexDigit(sequence[7]) &amp;&amp; isHexDigit(sequence[8]) &amp;&amp; isHexDigit(sequence[9]) </span><span class="cov0" title="0">{
                        return fmt.Sprintf("Matches the Unicode character U+%s", sequence[2:10])
                }</span>
                <span class="cov0" title="0">return "Invalid extended Unicode escape sequence"</span>
        case 'N':<span class="cov0" title="0">
                if len(sequence) &gt; 3 &amp;&amp; sequence[2] == '{' </span><span class="cov0" title="0">{
                        end := strings.IndexByte(sequence[2:], '}')
                        if end &gt; 0 </span><span class="cov0" title="0">{
                                name := sequence[3 : 2+end]
                                return fmt.Sprintf("Matches the Unicode character named '%s'", name)
                        }</span>
                }
                <span class="cov0" title="0">return "Invalid Unicode name escape sequence"</span>
        default:<span class="cov0" title="0">
                return fmt.Sprintf("Matches the character '%c' literally", sequence[1])</span>
        }
} </pre>
		
		<pre class="file" id="file8" style="display: none">package utils

// Version information set during build by the Makefile
var (
        // Version is the semantic version of the application
        Version = "0.1.0-dev"
        
        // GitCommit is the git commit hash of the build
        GitCommit = "unknown"
        
        // BuildDate is the date when the application was built
        BuildDate = "unknown"
)

// GetVersionInfo returns a formatted string with the version information
func GetVersionInfo() string <span class="cov8" title="1">{
        return "Unregex " + Version + " (" + GitCommit + ") built on " + BuildDate
}</span>

// Description returns a short description of the application
func Description() string <span class="cov8" title="1">{
        return "A tool to visualize and explain regular expressions"
}</span>

// FormatPattern formats a regex pattern for display
func FormatPattern(pattern string) string <span class="cov0" title="0">{
        return pattern
}</span>

// IsValidFormat checks if the specified regex format is supported
func IsValidFormat(format string) bool <span class="cov8" title="1">{
        validFormats := map[string]bool{
                "go":     true,
                "pcre":   true,
                "posix":  true,
                "js":     true,
                "python": true,
        }
        
        return validFormats[format]
}</span>

// GetFormatName returns a readable name for the format
func GetFormatName(format string) string <span class="cov8" title="1">{
        formatNames := map[string]string{
                "go":     "Go Regexp",
                "pcre":   "Perl Compatible Regular Expressions (PCRE)",
                "posix":  "POSIX Extended Regular Expressions",
                "js":     "JavaScript RegExp",
                "python": "Python re",
        }
        
        if name, ok := formatNames[format]; ok </span><span class="cov8" title="1">{
                return name
        }</span>
        <span class="cov8" title="1">return "Unknown Format"</span>
} </pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
